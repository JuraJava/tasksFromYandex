/**
 * Условие:
 * На столе лежит кучка из NN спичек. Двое играют в такую игру. За один ход разрешается взять из кучки одну, две или три
 * спички, так чтобы оставшееся количество спичек не было простым числом (например, можно оставить в кучке 1 или 4
 * спички, но нельзя оставить 2 или 3). Выигрывает тот, кто забирает последнюю спичку. Требуется определить, кто из
 * игроков имеет выигрышную стратегию.
 *
 * Формат ввода
 * Вводится одно число NN (1≤N≤10 0001≤N≤10000).
 *
 * Формат вывода
 * Выведите число 1, если при правильной игре победит первый игрок (который делает первый ход), или число 2,
 * если при правильной стратегии победит второй игрок.
 *
 * Ограничение времени
 * 1 с
 * Ограничение памяти
 * 256 МБ
 */

import java.util.Scanner;

public class Main18 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        // Решето Эратосфена для определения простых чисел
        boolean[] isPrime = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            isPrime[i] = true;
        }

        // 0 и 1 не являются простыми числами
        isPrime[0] = false;
        isPrime[1] = false;

        for (int i = 2; i * i <= n; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= n; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        // Динамическое программирование: dp[i] = выигрышна ли позиция с i спичками
        boolean[] dp = new boolean[n + 1];
        dp[0] = false; // позиция без спичек проигрышна

        for (int i = 1; i <= n; i++) {
            boolean winning = false;
            // Расчитываем все доступные ходы: взять 1, 2 или 3 спички
            for (int take = 1; take <= 3; take++) {
                int next = i - take;
                // Ход разрешён, если остаток не простой (включая 0)
                if (next >= 0 && !isPrime[next]) {
                    // Если можем перейти в проигрышную позицию, то текущая выигрышна
                    if (!dp[next]) {
                        winning = true;
                        break;
                    }
                }
            }
            dp[i] = winning;
        }
        System.out.println(dp[n] ? 1 : 2);
    }
}